// ДОМАШНЕЕ ЗАДАНИЕ
//   Задание 1:
//     Написать функцию pow(x, n), которая возвращает x в степени n,
//     иначе говоря, умножает x на себя n раз и возвращает результат.
//     Запросить у пользователя x и n, а затем вывести результат pow(x, n).
//     В этой задаче функция обязана поддерживать только натуральные значения n, т.е. целые от 1 и выше.



// function pow(x, n) {

//     if (n == 1) {
//         return x;
//     } else {
//         return x *= pow(x, n - 1);
//     }
// }

// var x = +prompt('number')
// var n = +prompt('number')

// if (n < 0 || n == '' || !Number.isInteger(n)) {
//     alert('Введите целую степень!')
// } else {
//     alert(pow(x, n))
// }




//   Задание 2:
//     Написать функцию sumTo(n), которая для данного n вычисляет сумму чисел от 1 до n, например:
//       sumTo(1) = 1
//       sumTo(2) = 2 + 1 = 3
//       sumTo(3) = 3 + 2 + 1 = 6
//       sumTo(4) = 4 + 3 + 2 + 1 = 10
//       sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050



//     Сделать три варианта решения:
//       - с использованием цикла
//       - через рекурсию, sumTo(n) = n + sumTo(n-1) для n > 1
//       - с использованием формулы для суммы арифметической прогрессии

//     Ответить на вопросы в комментариях:
//       Какой вариант решения самый быстрый? Самый медленный? Почему?
//       Можно ли при помощи рекурсии посчитать sumTo(100000)? Если нет, то почему?


//цикл

// function sumTo(n) { //самый медленный но этот способ не использует контестный стейк а соответственно и не использует большой объем памяти

//     var a = 0;

//     for (i = 0; i <= n; i++) {
//         a += i
//     }

//     return a;
// }



//рекурсия 

// function sumTo(n) { //самый быстрый способ код можно легко поддерживать минус ограничена глубина рекрсии потому каждый раз рекурсирую записывается новый контекс 
//     // с записию в ппамять  что в свою очередь для больших процесов требует большое колво памяти

//     if (n === 1) return 1;
//     return n + sumTo(n - 1);
// }

// alert(sumTo(100000)); //Максимальная глубина рекурсии ограничена движком JavaScript. 



//формула для суммы арифметической прогрессии

// function sumTo(n) { // наверное самая быстрая и не использует большой объем памяти

//     return n * (n + 1) / 2;
// }
// alert(sumTo(100));





//   Задание 3:
//     Разработать функцию treeSum, которая будет принимать массив, элементы которого могут быть числами или снова массивами,
//     и так до любого уровня вложенности. Функция должна рассчитать и вернуть сумму всех числовых элементов массива.
//     Некоторые уточняющие условия:
//       - Если работаем с числом - должна присутствовать проверка на то, что это число и оно корректно (не NaN)
//       - Если работаем с массивом - для определения массива метод isArray использовать запрещено, необходимо нагуглить
//         способ, как определить, что перед вами массив - с использованием только пройденных тем
//       - Другие значения, помимо числа и массива, разрешается не обрабатывать, однако они не должны ломать работу функции
//       - Функция должна быть чистой
//       - При написании функции не описывать каких-либо вложенных в неё функций
//       - При решении также запрещено использование методов join/split и всего того, что еще не было пройдено
//     Проверить работу функции можно на следующем массиве (сумма должна быть равна 50):
//       [
//         5, 7,
//         [4, [2], 8, [1, 3], 2],
//         [9, []],
//         1, 8
//       ]
// Array[element] == typeof Number && Array[element] != null && Array.length > 0)

// i == Array[element]
var arr = [
    5, 7, [4, [2], 8, [1, 3], 2],
    [9, []],
    1, 8
];

//124,2,8,1,3,29,18

//typeof Number(array[i]) && isNaN(array[i]
//var i = 0; i < array.length; i++




function treeSum(array) {
    var sum = 0;
    for (var i = 0; i < array.length; i++) {
        var item = array[i];
        if (typeof(item) == 'number' && item != NaN) {
            sum += item;
        } else if (typeof(item) == 'object') {
            sum += treeSum(item);

            //console.log(item);
        }

        // console.log(sum);
    }
    return sum


}











//     if (typeof Number(array[i]) && isNaN(array[i]) {
//             treeSum(i)
//         } else {
//             sum += i;
//         }






console.log(treeSum(arr));










// var arr = [
//     5, 7, [4, [2], 8, [1, 3], 2],
//     [9, []],
//     1, 8
// ];
// var sum = 0;
// var num;
// var length;
// checkNum(arr);
// checkArray(arr);
// console.log(treeSum(arr));

// function checkNum() {
//     for (value of arr) {
//         value !== NaN ? num = true : alert('есть не верное значение')
//     }
// }
// // console.log(num);

// function checkArray() {
//     for (var i = 0; i < arr.length; i++) {
//         i >= 0 ? length = true : alert('это не массив');
//     }
// }



// function treeSum(array) {
//     if (num === true && length === true) {
//         array.forEach(function(value, index) {
//             value instanceof Array ? treeSum(value) : sum += value;
//             return sum;
//         });
//     }
//     return sum
// }